!pip install sumy



import requests
import urllib.request
import time
from bs4 import BeautifulSoup



url = "https://americanliterature.com/childrens-stories/cinderella"
response = requests.get(url)

response


soup = BeautifulSoup(response.content, 'html.parser')


from __future__ import absolute_import
from __future__ import division, print_function, unicode_literals



from sumy.parsers.html import HtmlParser
from sumy.parsers.plaintext import PlaintextParser
from sumy.nlp.tokenizers import Tokenizer
from sumy.summarizers.lsa import LsaSummarizer as Summarizer
from sumy.nlp.stemmers import Stemmer
from sumy.utils import get_stop_words



LANGUAGE = "english"
SENTENCES_COUNT = 10

if __name__ == "__main__":
    url = "https://en.wikipedia.org/wiki/Automatic_summarization"
    parser = HtmlParser.from_url(url, Tokenizer(LANGUAGE))
    # or for plain text files
    # parser = PlaintextParser.from_file("document.txt", Tokenizer(LANGUAGE))
    stemmer = Stemmer(LANGUAGE)

    summarizer = Summarizer(stemmer)
    summarizer.stop_words = get_stop_words(LANGUAGE)

    for sentence in summarizer(parser.document, SENTENCES_COUNT):
        print(sentence)
        
        
        
if __name__ == "__main__":
    url = "https://americanliterature.com/childrens-stories/cinderella"
    parser = HtmlParser.from_url(url, Tokenizer(LANGUAGE))
    # or for plain text files
    # parser = PlaintextParser.from_file("document.txt", Tokenizer(LANGUAGE))
    stemmer = Stemmer(LANGUAGE)

    summarizer = Summarizer(stemmer)
    summarizer.stop_words = get_stop_words(LANGUAGE)

    for sentence in summarizer(parser.document, SENTENCES_COUNT):
        print(sentence)
        
        
   summarizer(parser.document, SENTENCES_COUNT)
   
   
  text=""
for sentence in summarizer(parser.document, SENTENCES_COUNT):
        text=text+str(sentence)
        
        
  import re
import string


query=re.split("[" + string.punctuation + "]+", text)


type(query)


!pip install gtts
!pip install mutagen
!pip install sk-video
!pip install textblob


from lxml import html  
import csv,os,json
import requests
import sys
import time
#from exceptions import ValueError
from time import sleep
from bs4 import BeautifulSoup
import urllib.request
from signal import signal, SIGPIPE, SIG_DFL
signal(SIGPIPE,SIG_DFL) 


headers = {'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.90 Safari/537.36'}




def url_image(query):
  page = requests.get(query,headers=headers,verify=False)
  doc = html.fromstring(page.content)
  soup = BeautifulSoup(page.text, 'html.parser')
  data = soup.find(id='sc')
  return data['value']
def get_image_links(url):
  page = requests.get(url,headers=headers,verify=False)
  doc = html.fromstring(page.content)
  soup = BeautifulSoup(page.text, 'html.parser')
  img_links = soup.find_all(class_='link')
  result=[]
  counter=0
  for i,x in enumerate(img_links):
    try:
      requests.get(x['href'],headers=headers,verify=False)
      extension=x['href']
      extension=extension[-3:]
      print("Extension is ",extension)
      if  extension=="gif":
        continue
      if (counter<2):
        result.append(x['href'])
        counter=counter+1
      else:
        break
    except:
      print("Exception occured but passed")
      
  return result
def preprocess_query(query):
  return query.replace(" ","+")
def preprocess_request(request):
  request=request.replace("!",".")
  request=request.replace('?','.')
  request=request.replace(';','.')
  request=request.replace('|','.')
  request=request.replace('ред','.')
  return request.split(".")
def generate_image_links(query):
  image_array=[]
  request=preprocess_request(query)
  for i in request:
    query=i
    result =url_image("https://www.dogpile.com/")
    base_url="https://www.dogpile.com/?qc=images&sc="
    image_search_url=base_url+result;
    result2=url_image(image_search_url)
    query=preprocess_query(query)
    base_query_url="https://www.dogpile.com/serp?q="+query+"&sc="
    query_url=base_query_url+result2;
    img_links=get_image_links(query_url)
    for i in (img_links):
      image_array.append(i)
  return image_array
def image_downloader(request):
  for i,x in enumerate(request):
    print("value of i : ",i," value of x : ",x)
    page = requests.get(x,headers=headers,verify=False)
    with open("img-"+str(i)+'.jpg', 'wb') as f:  
      f.write(page.content)
    f.close()
    
  print("Downloading of image done")
  return
def moving_to_project_directory():
  print("Enter your project name")
  project_name=input()
  if not os.path.exists(project_name):
    os.makedirs(project_name)
    os.chdir(project_name)
    print("Successfully created project ",project_name)
    return
  else:
    print("Project already exists please try another name")
    return moving_to_project_directory()
def return_to_working_directory():
  os.chdir("..")
  print("successfully returned to working directory")
        
        
moving_to_project_directory()
query_article=text
query_article_2=generate_image_links(query_article)
image_downloader(query_article_2)
query_text=preprocess_request(query_article)


from gtts import gTTS 

import os 
from mutagen.mp3 import MP3
from textblob import TextBlob

duration_array=[]

# Language in which you want to convert 
# Passing the text and language to the engine, 
# here we have marked slow=False. Which tells 
# the module that the converted audio should 
# have a high speed 
try:
  b = TextBlob(query_article)
  language=b.detect_language()
  print("Detected language ",language)
except:
  print("unable to detect language continued with  english")
  pass
  
  
  
  

#creating full length audio
mytext=query_article
myobj = gTTS(text=mytext,lang=language, slow=False) 
myobj.save("audio.mp3")


#creating linewise audio
counter=0
for i,x in enumerate(query_text):
  try:
    mytext=x
    myobj = gTTS(text=mytext, lang=language, slow=False) 
    myobj.save(str(i)+".mp3")
    audio = MP3(str(i)+".mp3")
    duration_array.append(audio.info.length)
    duration_array.append(audio.info.length)
    counter=counter+1
  except:
    pass

total_voices=2*counter





        

!pip install nltk

import nltk;
nltk.download('punkt')




!ffmpeg -encoders

!ffmpeg -framerate 2 -i img-%d.jpg video.avi





import os 
import cv2  
from PIL import Image  
  
# Checking the current directory path 
#print(os.getcwd())  
  
# Folder which contains all the images 
# from which video is to be generated 
#os.chdir("C:\\Python\\Geekfolder2")   
#path = "C:\\Python\\Geekfolder2"
  
mean_height = 0
mean_width = 0
  
num_of_images = len(os.listdir('.')) 
# print(num_of_images) 
  
for file in os.listdir('.'): 
    im = Image.open(os.path.join(path, file)) 
    width, height = im.size 
    mean_width += width 
    mean_height += height 
    # im.show()   # uncomment this for displaying the image 
  
# Finding the mean height and width of all images. 
# This is required because the video frame needs 
# to be set with same width and height. Otherwise 
# images not equal to that width height will not get  
# embedded into the video 
mean_width = int(mean_width / num_of_images) 
mean_height = int(mean_height / num_of_images) 
  
# print(mean_height) 
# print(mean_width) 
  
# Resizing of the images to give 
# them same width and height  
for file in os.listdir('.'): 
    if file.endswith(".jpg") or file.endswith(".jpeg") or file.endswith("png"): 
        # opening image using PIL Image 
        im = Image.open(os.path.join(path, file))  
   
        # im.size includes the height and width of image 
        width, height = im.size    
        print(width, height) 
  
        # resizing  
        imResize = im.resize((mean_width, mean_height), Image.ANTIALIAS)  
        imResize.save( file, 'JPEG', quality = 95) # setting quality 
        # printing each resized image name 
        print(im.filename.split('\\')[-1], " is resized")  
  
  
# Video Generating function 
def generate_video(): 
    image_folder = '.' # make sure to use your folder 
    video_name = 'mygeneratedvideo.avi'
    os.chdir("C:\\Python\\Geekfolder2") 
      
    images = [img for img in os.listdir(image_folder) 
              if img.endswith(".jpg") or
                 img.endswith(".jpeg") or
                 img.endswith("png")] 
     
    # Array images should only consider 
    # the image files ignoring others if any 
    print(images)  
  
    frame = cv2.imread(os.path.join(image_folder, images[0])) 
  
    # setting the frame width, height width 
    # the width, height of first image 
    height, width, layers = frame.shape   
  
    video = cv2.VideoWriter(video_name, 0, 1, (width, height))  
  
    # Appending the images to the video one by one 
    for image in images:  
        video.write(cv2.imread(os.path.join(image_folder, image)))  
      
    # Deallocating memories taken for window creation 
    cv2.destroyAllWindows()  
    video.release()  # releasing the video generated 
  
  
# Calling the generate_video function 
generate_video() 






import skvideo.io
import numpy as np
import cv2
img=[]
writer = skvideo.io.FFmpegWriter("image_video.mp4")
for i in range(total_voices):
  try:
    img.append(cv2.imread(str(i)+".jpg"))
    img[i] = cv2.cvtColor(img[i], cv2.COLOR_BGR2RGB)
    img[i]=cv2.resize(img[i],(720,480))
    for j in range(int(duration_array[i]*25)):
      writer.writeFrame(img[i])
  except:
    print("unable to read img")
    pass
writer.close()




import cv2
import numpy as np
import glob



!ffmpeg -i video.avi -i audio.mp3 -map 0:0 -map 1:0 -c:v copy -c:a copy result.mp4



